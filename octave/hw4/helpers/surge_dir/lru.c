/****************************************************************************/
/*                  Copyright 1997, Trustees of Boston University.          */
/*                               All Rights Reserved.                       */
/*                                                                          */
/* Permission to use, copy, or modify this software and its documentation   */
/* for educational and research purposes only and without fee is hereby     */
/* granted, provided that this copyright notice appear on all copies and    */
/* supporting documentation.  For any other uses of this software, in       */
/* original or modified form, including but not limited to distribution in  */
/* whole or in part, specific prior permission must be obtained from Boston */
/* University.  These programs shall not be used, rewritten, or adapted as  */
/* the basis of a commercial software or hardware product without first     */
/* obtaining appropriate licenses from Boston University.  Boston University*/
/* and the author(s) make no representations about the suitability of this  */
/* software for any purpose.  It is provided "as is" without express or     */
/* implied warranty.                                                        */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* Utility Name: LRU:  Generates an LRU stream from inputs                  */
/* Authors:      Paul Barford                                               */
/* Rev:   v1.3 4/22/98                                                      */
/*                                                                          */
/*                                                                          */
/* Description:                                                             */
/*                                                                          */
/* This program generates a stream of references for the objects generated  */
/* by object.c.  Each object consists of a set of files which will be       */
/* requested by the SURGE client(s) when an object name appears in the      */
/* sequence generated by this program.  The order of object names in the    */
/* request sequence is generated so that they follow as closely as possible */
/* a model distribution which in this code is a lognormal distribution.     */
/*                                                                          */
/* Inputs:                                                                  */
/*                                                                          */
/* The parameters for the program are listed in the DEFINE area of the      */
/* program header.  The input files to the program are mout.txt (from       */
/* match.c) which has format <number of references> <file size>             */
/* <group number> and objout.txt (from object.c).  Each row in objout.txt   */
/* contains the file names of the files associated with an object.          */
/*                                                                          */
/* Run this program by typing the following:                                */
/*                                                                          */
/*                                lru                                       */
/*                                                                          */
/* A probablistic sliding window is used to generate the sequence.  The key */
/* here is to make the window size wide enough so that the most popular doc */
/* is accessed fairly evenly throughout the sequence while maintaining a    */
/* stack distance that comes close to the ideal value at each point.  The   */
/* rule of thumb is for a stack size of 1,000 docs, use window size 6 and   */
/* for stack size of 10,000 docs use window size 3 (for mu = 1.5).  As the  */
/* value for mu goes up (eg. from 1.5 to 2.0) then the window size must     */
/* also go up from eg. from 6 to 10 (for # docs = 1000).                    */
/* The heuristic for window size that we use for multiple clients with a    */
/* MU of 1.83 is:                                                           */
/*                     # Clients       Window Size                          */
/*                     ---------       -----------                          */
/*                         1                20                              */
/*                         2                14                              */
/*                         3                 7                              */
/*                         4                 5                              */
/*                         5                 2                              */
/*                                                                          */
/* Outputs:                                                                 */
/*                                                                          */
/* The program outputs a couple files:                                      */
/*                                                                          */
/*   lruout.txt - a string of stack distances - use this to analyze the     */
/*                stack distances of sequence                               */
/*   names.txt - the object name prefixes read by Surgemaster.c which match */
/*               the stack distance measures in lruout.txt                  */
/*                                                                          */
/* The program also outputs a "table" after it completes.  This table shows */
/* the frequency of access of the most popular file in each 10% of the      */
/* generated sequence.  It is important that requests for the most popular  */
/* file are fairly evenly distributed throughout the sequence.  This can be */
/* adjusted by growing or shrinking the window size.                        */
/*                                                                          */
/* NOTE:  You must compile the program with the -lm qualifier since it uses */
/* the math.h header file.                                                  */
/*                                                                          */
/* Rev 1.3  There is a major change for this release in that now the        */
/*          the sequence generated by this file is for OBJECTS and not      */
/*          FILES.  The numbers placed in names.txt now relate to object    */
/*          names (simply the index into objout.txt) and not the file names */
/*          generated by files.c.                                           */
/*                                                                          */
/****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXTRACE 10000      /*   MAX number of input files handled          */
#define MAXSEQ 1000000      /*   MAX number of documents in output sequence */

/*  The following values need to be changed per the above documentation if  */
/* multiple clients are used in a SURGE test.                               */

#define SEED 1              /*   Seed value for drand48                     */
#define WINDOW 20           /*   Size of sliding window                     */
#define NOCLIENTS 1         /*   Number of clients used in the test         */

/* The following are the parameters used in the distribution which          */
/* determines the distances for the LRU stack.  The model for this temporal */
/* reference locality is lognormal.                                         */

#define LOGNMU 4.214         /*   log(mean of LRU stack dist)              */
#define LOGNSD 2.187         /*   log(stdev of RLU stack dist)             */

/* Define routines used in this program */

void getinputs();
void initialize();
void results();
void lognormal(float, float, long, int);

/* Define global variables used in this program */

long numrefs;               /* total number of values in sequence file      */
long num_infiles;           /* total number of input values                 */
long num_baselone;          /* number of objects from objout.txt            */
long refs[MAXTRACE];        /* reference numbers from mout.txt              */
long size[MAXTRACE];        /* file sizes from mout.txt                     */
long stack[MAXTRACE];       /* LRU stack                                    */
long baselone[MAXTRACE];    /* names of base and loner files from objout.txt*/
long trgtseq[MAXSEQ];       /* target sequence of values from model dist.   */
long seqence[MAXSEQ];       /* holds sequence indexes                       */
long names[MAXSEQ];         /* holds the file name prefixes                 */


//BOKI
void usage(){
  	printf("\nUsage: lru <seed> <window size>\n\n");
  	printf("<seed> - rnd generator seed\n");
  	printf("<window size> - size of sliding window (see doc. for more info)\n");
  	printf("Both are larger then zero.\n\n");
  	exit(1);
}


/****************************************************************************/
/* Main simply calculates the sequence of requested objects                 */
/****************************************************************************/

int main(int argc, char *argv[])
{

  int flag;
  long i, j, x, y, uplarge, totreq, sumreq, toptrk[10], topdoc;
  long largtrk[10], largdoc;
  float chosno;
  //BOKI
  long d_window = WINDOW;
  long d_seed = SEED;
  
  if (argc < 3) usage();
  else{
  	d_seed = atol(argv[1]);
	d_window = atol(argv[2]);
	if (d_seed == 0 || d_window == 0) usage();
  }

  printf("SEED = %ld, WINDOW = %ld\n", d_seed, d_window);

/****************************************************************************/
/* Initialize variables.                                                    */
/****************************************************************************/

  numrefs = 0;        /* aggregate number of references in input            */
  num_infiles = 0;    /* number of lines in mout.txt                        */
  num_baselone = 0;   /* number of lines in objout.txt                      */
  topdoc = 0;                  /* find the most popular base/loner document */
  largdoc = 0;                 /* find the largest base/loner document      */
  for(i=0;i<10;i++) toptrk[i] = 0;  /* track most popular base/loner object */
  for(i=0;i<10;i++) largtrk[i] = 0; /* track the largest base/loner object  */

/****************************************************************************/
/* Initialize arrays.                                                       */
/****************************************************************************/

  initialize();

  srand48(SEED);

/****************************************************************************/
/* Read input file.                                                         */
/****************************************************************************/

  getinputs();

/****************************************************************************/
/* Now calculate lru stream using the probablistic sliding window method.   */
/* First load the trgtseq array with values from a lognormal distribution   */
/* using mean and standard deviation from empirical values.  Then load the  */
/* stack.  Then select objects from the stack based on distances from the   */
/* trgtseq within the window.  Load the sequence array with the object names*/
/* which are actually indexes into the objout.txt array.                    */
/****************************************************************************/

  /* Find largest size base/loner file, object with largest number of       */
  /* requests and aggregate the number of references to objects             */

  for(i=0;i<num_baselone;i++)
    {
      if(refs[baselone[i]] > refs[baselone[topdoc]]) topdoc = i;
      if(size[baselone[i]] > size[baselone[largdoc]]) largdoc = i;
      numrefs += refs[baselone[i]];
    }

  /* Load up the target sequence array with values from model distribution  */

  lognormal(LOGNMU, LOGNSD, numrefs, num_baselone);

  /* Now generate the object name sequence via probablistic sliding window  */ 

  printf("Generating sequence via probablistic sliding window...\n");
  for(i=0;i < num_baselone;i++) stack[i] = i; /* load stack with indexes    */
  for(i=0;i < numrefs;i++) {                  /* cycle thru LRU refs        */
    chosno = drand48();                       /* pick uniform random #      */
    totreq = 0;
    sumreq = 0;
    for(j=0;j <= 2*d_window; j++) {           /* find total reqs in window  */
      x = trgtseq[i] - d_window + j;          /* set stack pointer          */
      if(x >= 0 && x <= num_baselone -1)      /* stay within stack          */
	totreq += refs[baselone[stack[x]]];   /* aggregate refs in window   */
    }
    flag = 0;
    y = trgtseq[i];                           /* set initial value for y    */
    for(j=0;j <= 2*d_window; j++) {           /* find agg reqs in window    */
      x = trgtseq[i] - d_window + j;          /* set stack pointer          */
      if(x >= 0 && x <= num_baselone -1) {    /* stay within stack          */
	sumreq += refs[baselone[stack[x]]];   /* aggregate requests         */
	if ((float)sumreq/totreq >= chosno) { /* choose the next line       */
	  y = x;                              /* set y to next obj index    */
	  chosno = 2.0;                       /* prevent overwrite of line  */
	}
      }                                       /* next obj is now selected   */
    }
    if(refs[baselone[stack[y]]] == 0) { /* Insure remaining refs for obj>0  */
      y = num_infiles - 1;           /* if not take first non 0 off bottom  */
      while(refs[baselone[stack[y]]] == 0 && y >= 0) y--;
    }
    refs[baselone[stack[y]]] -= 1;    /* Decrement from #refs for doc.      */
    seqence[i] = y;                   /* Capture new sequence               */
    names[i] = stack[y] ;
    uplarge = stack[y];               /* Update stack                       */
    for(j=y;j > 0;j--) {
      stack[j] = stack[j-1];
    }
    stack[0] = uplarge;
    uplarge = floor(10*i/numrefs);    /* Update info on topdoc and largdoc  */
    if(stack[0] == topdoc) toptrk[uplarge]++;
    if(stack[0] == largdoc) largtrk[uplarge]++;
  }
  for(i=0;i < num_infiles;i++) stack[i] = i;  /* stack in deceding ref ord  */
  for(i=0;i <10;i++) printf("Top%ld = %ld Lrg = %ld\n",i,toptrk[i],largtrk[i]);

/****************************************************************************/
/* Write out results.                                                       */
/****************************************************************************/

  results();
  return 0;

} /* End Main */

/****************************************************************************/
/* This routine adds numbers from a lognormal distribution to the target    */
/* array.  The values used to parameterize the distribution are passed to   */
/* this function as well as the number of values to add.  Use the rejection */
/* method to add points.  We also include the max size of values so we dont */
/* try to take values from below the bottom of the stack.                   */
/****************************************************************************/

void lognormal(float MU, float SIGMA, long numpts, int maxsz)
{

  long i, j, lognum;
  float norm, u1, u2, u3, x;

  i = 0;
  while(i < numpts)
    {
      j = 0;
      while(j == 0) {
	u1 = drand48();
	u2 = drand48();
	x = -log(u1);
	if(u2 <= exp(-(pow(x - 1,2))/2)) j = 1;
      }
      u3 = drand48();
      if(u3 > 0.5) {
	norm = x;
      } else {
	norm = -x;
      }
      lognum = exp(MU + SIGMA * norm)/NOCLIENTS;
      if(lognum < maxsz) {
	trgtseq[i] = lognum;
	i++;
      }
    }

} /* End routine lognormal */

/****************************************************************************/
/* Get input values from mout.txt and objout.txt files                      */
/****************************************************************************/

void getinputs()
{
  int junk;
  long refno, insize, base;
  FILE *fp;

  /* Get reference and size data from mout.txt */

  if((fp = fopen("mout.txt", "r")) == NULL)
    {
      perror("Unable to open mout.txt\n");
      exit(1);
    }

  while( fscanf(fp, "%ld %ld %d\n", &refno, &insize, &junk) != EOF)
    {
      if(num_infiles > MAXTRACE)
	{
	  printf("Buffers filled before end of scan. Increase MAXTRACE\n");
	  exit(1);
	  }
      refs[num_infiles] = refno;
      size[num_infiles] = insize;
      num_infiles++;

    }

  /* Close the mout.txt */

  fclose(fp);

  /* Get the names of the base files in each object from objout.txt */

  if((fp = fopen("objout.txt", "r")) == NULL)
    {
      perror("Unable to open objout.txt\n");
      exit(1);
    }

  while( fscanf(fp, "%ld", &base) != EOF)
    {
      if(num_baselone > MAXTRACE)
	{
	  printf("Buffers filled before end of scan. Increase MAXTRACE\n");
	  exit(1);
	}
      baselone[num_baselone] = base;  /* Capture the name of the first file */
      num_baselone++;
      while(getc(fp) != '\n') {}      /* Ignore the embedded file names     */
    }

  /* Close the objout.txt */

  fclose(fp);

} /* End getinputs */

/****************************************************************************/
/* Initializes the data arrays                                              */
/****************************************************************************/

void initialize()
{

  long i;

/* Initialize data arrays to 0 */

  for(i=0;i<MAXTRACE;i++)
    {
      refs[i] = 0;
      size[i] = 0;
      baselone[i] = 0;
    }
  for(i=0;i<MAXSEQ;i++)
    {
      trgtseq[i] = 0;
      seqence[i] = 0;
      names[i] = 0;
    }

} /* End initialize */

/****************************************************************************/
/* Write results to lruout.txt which is a series of stack distances which   */
/* can be used to assess the resulting temporal locality.  Also write       */
/* name.txt which is the actual reference stream of object names which will */
/* be read by Surgemaster.c for request generation.                         */
/****************************************************************************/

void results()
{
  int i;
  FILE *fp1;

  /* Open the output file lruout.txt  */

  if((fp1 = fopen("lruout.txt", "w")) == NULL)
    {
      perror("Unable to open lruout.txt\n");
      exit(1);
    }
  for(i=0;i < numrefs;i++)
    {
      fprintf(fp1,"%ld\n", seqence[i]);
    }

  /* Close file lruout.txt */

  fclose(fp1);

  /* Open the output file name.txt  */

  if((fp1 = fopen("name.txt", "w")) == NULL)
    {
      perror("Unable to open name.txt\n");
      exit(1);
    }
  for(i=0;i <  numrefs;i++)
    {
      fprintf(fp1,"%ld\n", names[i]);
    }

  /* Close file name.txt */

  fclose(fp1);

} /* End results */









