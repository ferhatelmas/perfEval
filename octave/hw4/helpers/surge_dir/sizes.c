/****************************************************************************/
/*                  Copyright 1997, Trustees of Boston University.          */
/*                               All Rights Reserved.                       */
/*                                                                          */
/* Permission to use, copy, or modify this software and its documentation   */
/* for educational and research purposes only and without fee is hereby     */
/* granted, provided that this copyright notice appear on all copies and    */
/* supporting documentation.  For any other uses of this software, in       */
/* original or modified form, including but not limited to distribution in  */
/* whole or in part, specific prior permission must be obtained from Boston */
/* University.  These programs shall not be used, rewritten, or adapted as  */
/* the basis of a commercial software or hardware product without first     */
/* obtaining appropriate licenses from Boston University.  Boston University*/
/* and the author(s) make no representations about the suitability of this  */
/* software for any purpose.  It is provided "as is" without express or     */
/* implied warranty.                                                        */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* Utility Name: File Size Generator                                        */
/* Authors:      Paul Barford                                               */
/* Rev:    v1.4  4/6/98                                                     */
/*                                                                          */
/*                                                                          */
/* Description:                                                             */
/*                                                                          */
/* This enables you to generate a set of numbers which are the sizes of     */
/* files used by the SURGE benchmark.  The sizes are generated so as to     */
/* follow the models described in the Surge papers.  This model consists    */
/* of separate distributions for 1) HTML pages with embedded images (base), */
/* 2) Embedded images (embed), and 3) All other stand alone file (loner).   */
/* The distributions for the three are somewhat complex.  The distribution  */
/* for base files is a hybrid lognormal and pareto.  The distribution for   */
/* embed files is lognormal.  The distribution for loner file is a hybrid   */
/* lognormal and lognormal.  Since the values for sizes are generated at    */
/* random, there is a minimum size limit used in this program.              */
/*                                                                          */
/* Inputs:                                                                  */
/*                                                                          */
/* The parameters for the program are listed in the DEFINE area of the      */
/* program header.  The command line inputs consist of only the number      */
/* of points/numbers desired.                                               */
/*                                                                          */
/* Run this program by typing the following:                                */
/*                                                                          */
/*                           sizes {# points}                               */
/*                                                                          */
/* Outputs:                                                                 */
/*                                                                          */
/* The program outputs a single file yout.txt which contains  {file type}   */
/* {file size} sorted from smallest file size to largest.  The file type    */
/* is either base = 1, embed = 2, loner = 3.                                */
/*                                                                          */
/* NOTE:  The number of points specified by the user must be the same as    */
/* the number specified for zipf.c                                          */
/*                                                                          */
/* NOTE:  You must compile the program with the -lm qualifier since it uses */
/* the math.h header file.                                                  */
/*                                                                          */
/****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXTRACE 100000     /*   MAX number of points generated by program  */
#define SEED 1              /*   seed value for random number generator     */

/* The following are the parameters used in the distributions which make up */
/* the file size models (base, embed, and loner).  First define the         */
/* of the percent of files from each of the three types, then define the    */
/* parameters used for the base files, then the embed files and then the    */
/* loner files.                                                             */

#define PCTBASE 0.30        /*   percent total files which are of type base */
#define PCTEMBED 0.38       /*   percent total files which are of type embed*/
#define PCTLONER 0.32       /*   percent total files which are of type loner*/
#define MINSIZE 75          /*   Minimum size of files generated            */

#define BASEMU 7.630        /*   shape parameter for lognormal distribution */
#define BASESIGMA 1.001     /*   scale parameter for lognormal distribution */
#define BASEK 10000         /*   the measured minimum for pareto dist.      */
#define BASEALPHA 1.0       /*   shape parameter for pareto distribution    */
#define BASECUTOFF 0.93     /*   percent of base files from the body dist   */

#define EMBEDMU 8.215       /*   shape parameter for lognormal distribution */
#define EMBEDSIGMA 1.460    /*   scale parameter for lognormal distribution */

#define LONERMU1 7.101      /*   shape parameter for lognormal distribution */
#define LONERSIGMA1 1.200   /*   scale parameter for lognormal distribution */
#define LONERMU2 11.151     /*   shape parameter for lognormal distribution */
#define LONERSIGMA2 1.143   /*   scale parameter for lognormal distribution */
#define LONERCUTOFF 0.66    /*   percent of loner files from the first dist */

/* Define routines used in this program */

void initialize(char *);
void results();
void lognormal(float, float, long, int);
void pareto(long, float, long);
int compare(const void *first, const void *second);
void loadpoint(long, int);

/* Define global variables used in this program */

long tot;                   /* total of all sizes generated                 */
long pntindx;               /* index into the points and group arrays       */
long num_points;            /* total number of input trace files            */
long indx[MAXTRACE];        /* index used to sort by size                   */
long points[MAXTRACE];      /* array to hold output size                    */
long hold[MAXTRACE];        /* array to hold new points from distributions  */
int group[MAXTRACE];        /* array to hold the group membership           */

/****************************************************************************/
/* Main simply generates set of sizes per the given distributional models   */
/* for each of the three file types and places them in points array.        */
/****************************************************************************/

int main(int argc, char *argv[])
{

  long i, numbody, numbasepts, numembedpts, numlonerpts;

/****************************************************************************/
/* Initialize variables.                                                    */
/****************************************************************************/

  tot = 0;
  pntindx = 0;
  srand48(SEED);

/****************************************************************************/
/* Initialize arrays.                                                       */
/****************************************************************************/

  if (argc < 2)
    {
      printf("Usage:  {#points} \n");
      exit(1);
    }

  initialize(argv[1]);
  
/****************************************************************************/
/* We now populate the points and group arrays - do base, then embed then   */
/* loners.                                                                  */
/****************************************************************************/

  printf("Generating file size data...\n");
  numbasepts = num_points * PCTBASE;
  numembedpts = num_points * PCTEMBED;
  numlonerpts = num_points - numbasepts - numembedpts;

  /* Load the sizes for the base files - lognormal plus pareto */

  numbody = numbasepts * BASECUTOFF;
  while(pntindx < numbody)
    {
      lognormal(BASEMU, BASESIGMA, 1, MINSIZE);
      if(hold[0] < BASEK) loadpoint(0, 1);
      hold[0] = 0;
    }
  while(pntindx < numbasepts)
    {
      pareto(BASEK, BASEALPHA, 1);
      if(hold[0] >= BASEK) loadpoint(0, 1);
      hold[0] = 0;
    }

  /* Load up the sizes for the embedded files - lognormal */

  lognormal(EMBEDMU, EMBEDSIGMA, numembedpts, MINSIZE);
  for(i=0;i<numembedpts;i++) loadpoint(i, 2);

  /* Load up the sizes for the loner files - lognormal plus lognormal */

  numbody = numlonerpts * LONERCUTOFF;
  lognormal(LONERMU1, LONERSIGMA1, numbody, MINSIZE);
  for(i=0;i<numbody;i++) loadpoint(i, 3);
  lognormal(LONERMU2, LONERSIGMA2, numlonerpts - numbody, MINSIZE);
  for(i=0;i<(numlonerpts-numbody);i++) loadpoint(i, 3);

  /* Sort the output so that sizes appear in ascending order */

  qsort(indx,num_points,sizeof(indx[0]),compare);

  i = points[indx[num_points-1]];
  printf("Total bytes = %ld, Mean = %ld Max = %ld\n", tot, tot/num_points, i);

/****************************************************************************/
/* Write out results.                                                       */
/****************************************************************************/

  results();
  return 0;

} /* End Main */


/****************************************************************************/
/* This routine just transfers a point from the hold array to the points    */
/* array and adds the appropriate group number to the group array.          */
/****************************************************************************/

void loadpoint(long holdindx, int grp)
{
  points[pntindx] = hold[holdindx];
  group[pntindx] = grp;
  tot += hold[holdindx];
  pntindx++;
  hold[holdindx] = 0;
}

/****************************************************************************/
/* This is just a quick comparison routine which is used by qsort to sort by*/
/* file sizes (actually the indx array is what gets sorted).                */
/****************************************************************************/

int compare(const void *first, const void *second)
{
  return(points[*((long *)first)] - points[*((long *)second)]);
}

/****************************************************************************/
/* This routine adds numbers from a pareto distribution to the hold array.  */
/* The values used to parameterize the distribution are passed to this      */
/* function as well as the number of values to add.                         */
/****************************************************************************/

void pareto(long K, float ALPHA, long numpts)
{
  long i;

  i = 0;
  while(i < numpts)
    {
      hold[i] = pow(1.0 - BASECUTOFF, 1.0/ALPHA) * K/pow(drand48(), 1.0/ALPHA);
      i++;
    }

} /* End routine pareto */


/****************************************************************************/
/* This routine adds numbers from a lognormal distribution to the hold      */
/* array.  The values used to parameterize the distribution are passed to   */
/* this function as well as the number of values to add.  A mimimum size    */
/* value is also passed which insures that no files are sized below a value.*/
/* Use the rejection method to add points.                                  */
/****************************************************************************/

void lognormal(float MU, float SIGMA, long numpts, int minsz)
{
  long i, j, lognum;
  float norm, u1, u2, u3, x;

  i = 0;
  while(i < numpts)
    {
      j = 0;
      while(j == 0) {
	u1 = drand48();
	u2 = drand48();
	x = -log(u1);
	if(u2 <= exp(-(pow(x - 1,2))/2)) j = 1;
      }
      u3 = drand48();
      if(u3 > 0.5) {
	norm = x;
      } else {
	norm = -x;
      }
      lognum = exp(MU + SIGMA * norm);
      if(lognum >= minsz) {
	hold[i] = lognum;
	i++;
      }
    }

} /* End routine lognormal */

/****************************************************************************/
/* Initializes the data arrays used in the program.                         */
/****************************************************************************/

void initialize(char *npts)
{

  int i;

  num_points = atol(npts);

  if (MAXTRACE < num_points)
    {
      printf("Need to increase MAXTRACE \n");
      exit(1);
    }

/* Initialize the data arrays to 0 and index array data accordingly */

  for(i=0;i<MAXTRACE;i++)
    {
      points[i] = 0;
      group[i] = 0;
      hold[i] = 0;
      indx[i] = i;
    }
} /* End initialize */

/****************************************************************************/
/* The results routine opens file yout.txt and prints out the group and size*/
/* data.                                                                    */
/****************************************************************************/

void results()
{
  int i;
  FILE *fp1;

  /* Open the output file yout.txt  */

  if((fp1 = fopen("yout.txt", "w")) == NULL)
    {
      perror("Unable to open yout.txt\n");
      exit(1);
    }
  printf("Writing data to yout.txt\n");
  for(i=0;i<num_points;i++)
    {
      fprintf(fp1,"%d %ld\n", group[indx[i]], points[indx[i]]);
    }

  /* Close the output file  */

  fclose(fp1);

} /* End results */



