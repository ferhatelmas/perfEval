/****************************************************************************/
/*                  Copyright 1997, Trustees of Boston University.          */
/*                               All Rights Reserved.                       */
/*                                                                          */
/* Permission to use, copy, or modify this software and its documentation   */
/* for educational and research purposes only and without fee is hereby     */
/* granted, provided that this copyright notice appear on all copies and    */
/* supporting documentation.  For any other uses of this software, in       */
/* original or modified form, including but not limited to distribution in  */
/* whole or in part, specific prior permission must be obtained from Boston */
/* University.  These programs shall not be used, rewritten, or adapted as  */
/* the basis of a commercial software or hardware product without first     */
/* obtaining appropriate licenses from Boston University.  Boston University*/
/* and the author(s) make no representations about the suitability of this  */
/* software for any purpose.  It is provided "as is" without express or     */
/* implied warranty.                                                        */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* Utility Name: Matches results from Sizes and Zipf programs               */
/* Authors:      Paul Barford                                               */
/* Rev:     v1.4  4/10/98                                                   */
/*                                                                          */
/*                                                                          */
/* Description:                                                             */
/*                                                                          */
/* This program enables you to match the values in the output files which   */
/* are generated by zipf.c and sizes.c.  It outputs a matching between the  */
/* data collected in these files according to a number of possible choices. */
/* The idea is that we want to generate a matching between the file sizes   */
/* and popularity so that the resulting CDF matches a specified function.   */
/* For Rev. 1.4, this function has been enhanced to be a hybrid lognormal   */
/* and pareto which more accurately models the CDF of the empirical data.   */
/*                                                                          */
/* Inputs:                                                                  */
/*                                                                          */
/* The parameters for the program are listed in the DEFINE area of the      */
/* program header.  The input files from zipf.c and sizes.c are read into   */
/* the program.  The output from zipf.c is file zout.txt and has the        */
/* following format:  <doc number>, <num references>.  The output from      */
/* sizes.c is called yout.txt and has the following format: <group>         */
/* <file size> which is ordered from smallest file size value to largest.   */
/* The program takes a single value from the command line which is the      */
/* matching method choice.                                                  */
/*                                                                          */
/* Run this program by typing the following:                                */
/*                                                                          */
/*                            match {choice}                                */
/*                                                                          */
/* The choices are the following:                                           */
/*                                                                          */
/*         1:    Does the optimal matching over the entire function         */
/*         2:    Does the optimal matching focusing on the tail only        */
/*         3:    Does the optimal matching focusing on the head only        */
/*                                                                          */
/* We recommend using choice #2 or choice #1.                               */
/*                                                                          */
/* Outputs:                                                                 */
/*                                                                          */
/* The program outputs three files. mllcd.txt has the following columns:    */
/* <log(P[X>x])>, <log(filesize)> which can then be graphed to analyze      */
/* the tail (LLCD) of the matching.  mcdf.txt has the following column:     */
/* <filesize> which can then be used along with the empirical data to       */
/* analyze the body of the matching via CDF.  And, mout.txt is the file     */
/* which is the actual mapping between the file sizes and the number of     */
/* requests and is used by object.c to generate the request sequence.       */
/*                                                                          */
/* NOTE:  You must compile the program with the -lm qualifier since it uses */
/* the math.h header file.                                                  */
/*                                                                          */
/****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXTRACE 60000      /*   MAX number of input files handled          */
#define SELOUT 0            /*   Selects type of output                     */

/* The following are the parameters used in the distributions which make up */
/* the request size model.  In addition to the parameters for the lognormal */
/* and pareto distributions, include the percentage contribution of each to */
/* the overall hybrid distribution.                                         */

#define LOGN_MU 7.881       /*   shape parameter for lognormal distribution */
#define LOGN_SG 1.339       /*   scale parameter for lognormal distribution */
#define PARETO_K 34102      /*   the measured minimum for pareto dist.      */
#define PARETO_A  1.177     /*   shape parameter for pareto distribution    */
#define CUTOFF 0.93         /*   percent of files from the body dist        */

/* Define routines used in this program */

void getinputs( char *);
void initialize();
void results();
void accurate();
int compare(const void *first, const void *second);
float match_cdf(long);

/* Define global variables used in this program */

int choice;                 /* matching routine choice                      */
long num_rinfiles;          /* total number of ref input values             */
long num_finfiles;          /* total number of file size input values       */
int group[MAXTRACE];        /* group for which size is a member             */
long refs[MAXTRACE];        /* reference numbers from zout.txt              */
long ideal[MAXTRACE];       /* the ideal reference string for file sizes    */
long size[MAXTRACE];        /* file sizes from yout.txt                     */
long indx[MAXTRACE];        /* used to index arrays                         */
long indx1[MAXTRACE];       /* used to hold ideal value index               */
long usdn[MAXTRACE];        /* holds used indexes                           */
float prob[MAXTRACE];       /* log of probabilites for results              */
float flsz[MAXTRACE];       /* log of filesizes for results                 */


/****************************************************************************/
/* Main simply calculates the matching                                      */
/****************************************************************************/

int main(int argc, char *argv[])
{

  long i, j, k, k1, totint;
  float totreq, sumreq, newrq, terror, maxrq;
  long meanflsz, totflsz;

/****************************************************************************/
/* Initialize variables.                                                    */
/****************************************************************************/

  num_rinfiles = 0;
  num_finfiles = 0;
  meanflsz = 0;
  totflsz = 0;
  totreq = 0.0;
  sumreq = 0.0;
  totint = 0;
  newrq = 0.0;
  terror = 0.0;
  maxrq = 0.0;

/****************************************************************************/
/* Initialize arrays.                                                       */
/****************************************************************************/

  if (argc < 2)
    {
      printf("Usage: {matching choice} \n");
      exit(1);
    }

  initialize();

/****************************************************************************/
/* Read input file.                                                         */
/****************************************************************************/

  getinputs(argv[1]);

/****************************************************************************/
/* We now calculate the rslts.  The three choices are 1, 2, 3               */
/* Choice #1 is an implementation of the "optimal" matching method which    */
/* matches the sizes to the requests so that the aggregate error between an */
/* "ideal" CDF line (defined as sum of lognormal and pareto) and the line   */
/* produced by this matching is minimum.  Choice #2 is a method of matching */
/* which insures that the error between the matching and the ideal is       */
/* minimal in the tail.  We think that this is the choice that should be    */
/* used most often.  Choice #3 is a method of which insures that the error  */
/* iis minimal in the head.  All of These functions utilize the facts that  */
/* yout.txt (file sizes) are read in already sorted (ascending order)       */
/* and that zout.txt (total requests) is already sorted (decending order).  */
/*                                                                          */
/****************************************************************************/

  for(i=0;i<num_rinfiles;i++) 
    {
      totreq += refs[i];
      totflsz += size[i];
    }
  meanflsz = totflsz/num_rinfiles;

  switch(choice) {

  case 1:
    printf("Doing matching via minimal total error method\n");

    /* First generate all ideal total rqst values for each file size */
    sumreq = 0;
    for(i=0;i < num_finfiles;i++) {
      ideal[i] = totreq * match_cdf(size[i]) - sumreq;
      sumreq += ideal[i];
      if (ideal[i] > maxrq) maxrq = ideal[i];
    }

    /* Sort ideal rqst value index array in decending order*/
    qsort(indx1,num_finfiles,sizeof(indx1[0]),compare);

    /* Now switch the index value with the stored index value which has */
    /* the effect of matching the largest number of requests in zout.txt*/
    /* with the largest value in ideal array, next largest with next    */
    /* largest and so on which is proved to be optimal.                 */

    for(i=0;i < num_finfiles;i++) {
      j = 0;
      while(indx1[j] != i) j++;
      indx[i] = j;
    }
    printf("Maxrq = %f\n", maxrq);

    break;

  case 2:
    printf("Doing matching via minimal error in tail\n");

    for(i=0;i<num_rinfiles;i++) usdn[i] = 0;    /* Initialize used array */
    /* Now make the assignments in reverse order */
    sumreq = totreq;
    for(i=num_finfiles - 1;i > 0;i--) {
      if(size[i] != size[i-1]) {
	newrq = sumreq - totreq * match_cdf(size[i]);
	if (newrq > maxrq) maxrq = newrq;     /* Track the largest request */
	k = num_rinfiles-1;         /* set up default value for indx[i] */
	while(usdn[k] == 1 && k >= 0) k--;
	indx[i] = k;
	k1 = 0;                     /* set up default value for k1      */
	while(usdn[k1] == 1 && k1 < num_rinfiles) k1++;
	for(k=num_rinfiles-1;k >= 0;k--)
	  if (usdn[k] == 0 && refs[k] <= newrq) indx[i] = k; 
	for(k=0;k < num_rinfiles;k++)
	  if (usdn[k] == 0 && refs[k] >= newrq) k1 = k;
	if ((newrq - refs[indx[i]]) > (refs[k1] - newrq)) indx[i] = k1;
	sumreq -= refs[indx[i]];
	usdn[indx[i]] = 1;
      } else {    /* if files are same size assign smallest # requests */
	k = num_rinfiles-1;
	while(usdn[k] == 1 && k >= 0) k--;
	indx[i] = k;
	sumreq -= refs[indx[i]];
	usdn[indx[i]] = 1;
      }
    }
    k = num_rinfiles-1;  /* make assignment for smallest file */
    while(usdn[k] == 1 && k >= 0) k--;
    indx[i] = k;
    printf("Maxrq = %f\n", maxrq);

    break;

  case 3:
    printf("Doing matching via minimal error in head\n");

    for(i=0;i<num_rinfiles;i++) usdn[i] = 0;   /* Initialize used array */
    indx[0] = num_rinfiles - 1;       /* Make assignment for first file */
    sumreq += refs[indx[0]];
    usdn[indx[0]] = 1;
    for(i=1;i<num_finfiles;i++) {
      if(size[i] != size[i+1]) {
	newrq = totreq * match_cdf(size[i]) - sumreq;
	if (newrq > maxrq) maxrq = newrq;    /* Track the largest request */
	k = num_rinfiles-1;         /* set up default value for indx[i] */
	while(usdn[k] == 1 && k >= 0) k--;
	indx[i] = k;
	k1 = 0;                     /* set up default value for k1      */
	while(usdn[k1] == 1 && k1 < num_rinfiles) k1++;
	for(k=num_rinfiles-1;k >= 0;k--)
	  if (usdn[k] == 0 && refs[k] <= newrq) indx[i] = k; 
	for(k=0;k < num_rinfiles;k++)
	  if (usdn[k] == 0 && refs[k] >= newrq) k1 = k;
	if ((newrq - refs[indx[i]]) > (refs[k1] - newrq)) indx[i] = k1;
	sumreq += refs[indx[i]];
	usdn[indx[i]] = 1;
      } else {    /* if files are same size assign smallest # requests */
	k = num_rinfiles-1;
	while(usdn[k] == 1 && k >= 0) k--;
	indx[i] = k;
	sumreq -= refs[indx[i]];
	usdn[indx[i]] = 1;
      }
    }
    printf("Maxrq = %f\n", maxrq);

    break;

  default:

    printf("Oops, you need to select choices 1, 2, or 3!\n");
    exit(1);
    break;
  }

/* Choose SELOUT = 0 if you want to graph LLCD,                             */
/*        SELOUT = 1 if you want linear values of file size vs. CD.         */

  sumreq = 0.0;
  if(SELOUT == 0) 
    {
      for(i=0;i<num_finfiles;i++)
	{
	  sumreq += refs[indx[i]];
	  flsz[i] = log10(size[i]);
	  prob[i] = log10(1.0 - (float)sumreq/totreq);
	}
    }
   if(SELOUT == 1) 
     {
      for(i=0;i<num_finfiles;i++)
	{
	  flsz[i] = size[i];
	  sumreq += refs[indx[i]];
	  prob[i] = 1.0 - (float)sumreq/totreq;
	}
     } 

/* Calculate the "accuracy index" values for any/all matching choices       */
  
  accurate();

 
/****************************************************************************/
/* Write out results.                                                       */
/****************************************************************************/

  results();
  return 0;

} /* End Main */

/****************************************************************************/
/* This is the routine which calculates the ideal CDF based on the file size*/
/* which has been passed to it. Ideal CDF values are calculated as follows: */
/* Since the distribution is a hybrid, the contribution to the overall CDF  */
/* by each functions CDF is scaled by the number of points attributed to    */
/* the body (lognormal) and the tail (pareto).  This scaling is given by    */
/* CUTOFF.  The CDF for lognormal is calculated by using the erf (error     */
/* function) and the CDF for pareto is 1 - (K/x)^ALPHA.  In order to match  */
/* correctly, we use a modified value for K based on the cutoff value.      */
/****************************************************************************/

float match_cdf(long filesize)
{
  float val, reqval;

  if(filesize < PARETO_K) {
    val = (log(filesize) - LOGN_MU)/LOGN_SG;
    if(val < 0) {
      reqval = CUTOFF * (0.5 - 0.5 * erf(fabs(val/sqrt(2))));
    }else{
      reqval = CUTOFF * (0.5 + 0.5 * erf(val/sqrt(2)));
    }
  } else {
    val = pow((1.0 - CUTOFF),(1.0/PARETO_A));
    reqval =  (1.0 - pow(((float)PARETO_K * val/filesize),PARETO_A));
  }
  return(reqval);

} /* End match_cdf */

/****************************************************************************/
/* This is just a quick comparison routine which is used by qsort to sort   */
/* the ideal value array (actaully indx1 is what gets sorted).              */
/****************************************************************************/

int compare(const void *first, const void *second)
{
  return(ideal[*((long *)second)] - ideal[*((long *)first)]);
}

/****************************************************************************/
/* The accurate routine calculates an accuracy index for how well the model */
/* function tracks the ideal function.  It is a simple difference           */
/* calculation and is only used to show how well the three tests perform    */
/* relative to each other.                                                  */
/****************************************************************************/

void accurate()
{
  int i, maxindx;
  float newrq, sumreq, accur, tot, maxer;

  tot = 0;
  for(i=0;i<num_rinfiles;i++) tot += refs[i];
  sumreq = 0.0;
  accur = 0.0;
  maxer = 0.0;
  maxindx = 0;
  for(i=0;i<num_finfiles;i++) {
    newrq = tot * match_cdf(size[i]) - sumreq;
    if(newrq > refs[indx[i]]) {
      accur += newrq - refs[indx[i]];
      if ((newrq - refs[indx[i]]) > maxer) 
	{
	  maxer = newrq - refs[indx[i]];
	  maxindx = i;
	}
    } else {
      accur += refs[indx[i]] - newrq;
      if ((refs[indx[i]] - newrq) > maxer) 
	{
	  maxer = refs[indx[i]] - newrq;
	  maxindx = i;
	}
    }

    sumreq += newrq;
  }
  printf("Accumulated error = %f\n", accur);
  printf("Max error = %f Index = %d\n", maxer, maxindx);
  printf("Total Requests = %f\n", tot);

} /* End accurate */

/****************************************************************************/
/* Gets inputs from for number of requests from zout.txt and for file sizes */
/* from yout.txt                                                            */
/****************************************************************************/

void getinputs(char *inchoice)
{
  int grpnum;
  long junk, insize;
  FILE *fp;

  choice = atol(inchoice);

  /* Get request frequency input from file zout.txt */

  if((fp = fopen("zout.txt", "r")) == NULL)
    {
      perror("Unable to open zout.txt\n");
      exit(1);
    }

  while( fscanf(fp, "%ld %ld", &junk, &insize) != EOF)
    {
      if(num_rinfiles > MAXTRACE)
	{
	  printf("Buffers filled before end of scan. Increase MAXTRACE\n");
	  exit(1);
	  }
      refs[num_rinfiles] = insize;
      num_rinfiles++;

    }

  /* Close the input file zout.txt */

  fclose(fp);

  /*  printf("%ld Total entries in zout.txt \n", num_rinfiles); */

  /* Get file size input from file yout.txt */

  if((fp = fopen("yout.txt", "r")) == NULL)
    {
      perror("Unable to open yout.txt\n");
      exit(1);
    }

  while( fscanf(fp, "%d %ld", &grpnum, &insize) != EOF)
    {
      if(num_finfiles > MAXTRACE)
	{
	  printf("Buffers filled before end of scan. Increase MAXTRACE\n");
	  exit(1);
	  }
      size[num_finfiles] = insize;
      group[num_finfiles] = grpnum;
      num_finfiles++;

    }

  /* Close the input file yout.txt */

  fclose(fp);

  /*  printf("%ld Total entries in yout.txt \n", num_finfiles); */

} /* End getinputs */


/****************************************************************************/
/* The initialize routine initializes the arrays                            */
/****************************************************************************/

void initialize()
{

  long i;

/* Initialize the data arrays to 0 and indexes accordingly */

  for(i=0;i<MAXTRACE;i++)
    {
      refs[i] = 0;
      ideal[i] = 0;
      size[i] = 0;
      group[i] = 0;
      prob[i] = 0.0;
      flsz[i] = 0.0;
      indx[i] = i;
      indx1[i] = i;
    }

} /* End initialize */


/****************************************************************************/
/* The results routine opens mllcd.txt and mcdf.txt and writes the resulting*/
/* log-log complementary distribution (llcd) and cumulative distribution    */
/* function (cdf) in order to analyze the resulting request size            */
/* distribution.  It also writes mout.txt which contains the number of      */
/* requests assigned to the various files sizes.  This file is a key input  */
/* to objects.c, files.c and lru.c                                          */
/****************************************************************************/

void results()
{
  long i, j;
  FILE *fp1;

  /* Open the output file mllcd.txt  */

  if((fp1 = fopen("mllcd.txt", "w")) == NULL)
    {
      perror("Unable to open mllcd.txt\n");
      exit(1);
    }
  for(i=0;i<num_finfiles-1;i++)
    {
      fprintf(fp1,"%8.4f %8.4f \n", flsz[i], prob[i]);
    }

  /* Close the output file  mllcd.txt */

  fclose(fp1);

  /* Open the output file mout.txt  */

  if((fp1 = fopen("mout.txt", "w")) == NULL)
    {
      perror("Unable to open mout.txt\n");
      exit(1);
    }
  for(i=0;i<num_finfiles;i++)
    {
      fprintf(fp1,"%ld %ld %d\n", refs[indx[i]], size[i], group[i]);
    }

  /* Close the output file  mout.txt */

  fclose(fp1);

  /* Open the output file mcdf.txt  */

  if((fp1 = fopen("mcdf.txt", "w")) == NULL)
    {
      perror("Unable to open mcdf.txt\n");
      exit(1);
    }
  for(i=0;i<num_finfiles;i++)
    {
      for(j=0;j<refs[indx[i]];j++) 
	{
	  fprintf(fp1,"%ld\n", size[i]);
	}
    }

  /* Close the output file mcdf.txt */

  fclose(fp1);

} /* End results */






