/****************************************************************************/
/*                  Copyright 1997, Trustees of Boston University.          */
/*                               All Rights Reserved.                       */
/*                                                                          */
/* Permission to use, copy, or modify this software and its documentation   */
/* for educational and research purposes only and without fee is hereby     */
/* granted, provided that this copyright notice appear on all copies and    */
/* supporting documentation.  For any other uses of this software, in       */
/* original or modified form, including but not limited to distribution in  */
/* whole or in part, specific prior permission must be obtained from Boston */
/* University.  These programs shall not be used, rewritten, or adapted as  */
/* the basis of a commercial software or hardware product without first     */
/* obtaining appropriate licenses from Boston University.  Boston University*/
/* and the author(s) make no representations about the suitability of this  */
/* software for any purpose.  It is provided "as is" without express or     */
/* implied warranty.                                                        */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* Utility Name: OFF Time generator                                         */
/* Authors:      Paul Barford                                               */
/* Rev:    v1.0  5/12/98                                                    */
/*                                                                          */
/* Description:                                                             */
/*                                                                          */
/* This program will generate Inactive OFF times for SURGE.  Inactive OFF   */
/* times are the "think" times when users are reading a Web page.  Inactive */
/* OFF is modeled via pareto distribution.  We place a threshold of 30 min. */
/* for Inactive OFF times generated by this program.  There is also an      */
/* assumption that all OFF times will be at least one second.               */
/*                                                                          */
/* This program also generates the "session lengths" in terms of number of  */
/* objects selected.  For HTTP/1.1, the connection from client to server is */
/* persistent.  Thus, we must know the number of objects/documents the      */
/* client will select before the connections are closed.  For this purpose  */
/* we generate "session lengths" in terms of number of objects selected     */
/* between the time the first connect is opened until all are closed.  The  */
/* model for this is Inverse Gaussian and parameters are used from the      */
/* Huberman, Pitkow paper on the law of surfing.                            */
/*                                                                          */
/* Inputs:                                                                  */
/*                                                                          */
/* The parameters for the program are listed in the DEFINE area of the      */
/* program header.  The program takes no input from the command line but    */
/* does use the file NAME.TXT to determine how many OFF time values and to  */
/* session lengths to generate.                                             */
/*                                                                          */
/* Run this program by typing the following:                                */
/*                                                                          */
/*                                  offtime                                 */
/*                                                                          */
/* Outputs:                                                                 */
/*                                                                          */
/* The program outputs one file:  off.txt are the Inactive OFF times.  The  */
/* times in these files are in milliseconds.                                */
/*                                                                          */
/* NOTE:  This program must be compiled with the -lm qualifier to link the  */
/* math library.                                                            */
/*                                                                          */
/* Rev 1.0:  This revision removed the generation of Active OFF times.      */
/*           We no longer insert OFF times between each file transfer.      */
/*           With the introduction of the object model to SURGE (v1.0)      */
/*           only Inactive OFF times are generated and used. This rev.      */
/*           also generates the session length values.  This file replaces  */
/*           the file OFFTIME.C from previous releases of SURGE.            */
/*                                                                          */
/****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXOUTPUT 200000    /* max length of the object request sequence    */
#define SEED 1              /*   seed value for random number generator     */

/* The following are the parameters used in the distribution which          */
/* determines the values for Inactive OFF times.  The model for this is     */
/* pareto.                                                                  */

#define PARETOK 1           /* min value in seconds for off time            */
#define PARETOA 1.4         /* scale factor for pareto dist.                */
#define LIMIT 1800          /* limit for value of Inactive OFF in seconds   */

/* The following are the parameters used in the distribution which          */
/* determines the values for session lengths.  The model for this is inverse*/
/* Gaussian.                                                                */

#define INVGAUSSMU 3.86     /* mean value for number of objects selected    */
#define INVGAUSSLAMB 6.08   /* variance for number of objects selected      */
#define INVGAUSSMAX 95      /* max value for number of objects selected     */

/* Define routines used in this program */

void initialize();
void results();
void pareto(long, float, long);
void invgauss(float, float, long);

/* Define global variables used in this program */

long num_seq;               /* length of object sequence in NAME.TXT        */
float off[MAXOUTPUT];       /* inactive off times                           */
float cnt[MAXOUTPUT];       /* session lengths                              */


//BOKI
void usage(){
  	printf("\nUsage: surfoff <seed>\n\n");
  	printf("<seed> - rnd generator seed (> 0)\n\n");
  	exit(1);
}


/****************************************************************************/
/* Main begins by simply initializing the output arrays and then generating */
/* values from the Pareto and inverse Guassian distributions until the total*/
/* is equal to the sum of the requests from ONOUT.TXT.                      */
/****************************************************************************/

int main(int argc, char *argv[])
{
  long d_seed = SEED;

  if (argc < 2) usage();
  else{
  	d_seed = atol(argv[1]);
	if (d_seed == 0) usage();
  }

  printf("SEED = %ld\n", d_seed);


/****************************************************************************/
/* Initialize variables                                                     */
/****************************************************************************/

  num_seq = 0;

  srand48(d_seed);
  initialize();

/****************************************************************************/
/* Calculate the OFF times                                                  */
/****************************************************************************/

  printf("Generating OFF time values...\n");
  
  pareto(PARETOK, PARETOA, num_seq);

  printf("%ld Inactive OFF times generated\n", num_seq);

  printf("Generating Session Lengths...\n");

  invgauss(INVGAUSSMU, INVGAUSSLAMB, num_seq);

  printf("%ld Session lengths generated\n", num_seq);

/****************************************************************************/
/* Write out results.                                                       */
/****************************************************************************/

  results();
  return 0;

} /* End Main */

/****************************************************************************/
/* This routine adds numbers from a pareto distribution to the off array.   */
/* The values used to parameterize the distribution are passed to this      */
/* function as well as the number of values to add.                         */
/****************************************************************************/

void pareto(long K, float ALPHA, long numpts)
{
  float paretonum;
  long i;

  i = 0;
  while(i < numpts)
    {

      paretonum = (float)K / pow(drand48(), 1.0/ALPHA);
      if(paretonum <= LIMIT) {
	off[i] = paretonum;
	i++;
      }
    }

} /* End routine pareto */

/****************************************************************************/
/* This routine adds numbers from a inverse Gaussian distribution to the cnt*/
/* array.  The values used to parameterize the distribution are passed to   */
/* this function as well as the number of values to add.  The method of     */
/* generating variates from the inverse Gaussian distribution is from       */
/* Michael et. al.                                                          */
/****************************************************************************/

void invgauss(float mu, float lambda, long numpts)
{
  float invgnum;
  long i, j;
  float norm, u1, u2, u3, x, x1, y;

  i = 0;
  while(i < numpts)
    {

      /* First use rejection method to generate normal variate */

      j = 0;
      while(j == 0) {
        u1 = drand48();
        u2 = drand48();
        x = -log(u1);
        if(u2 <= exp(-(pow(x - 1,2))/2)) j = 1;
      }
      u3 = drand48();
      if(u3 > 0.5) {
        norm = x;
      } else {
        norm = -x;
      }

      /* Square this number to approximate a chi squared variate */

      y = norm * norm;

      /* Now apply the Michael method */

      x1 = mu + (mu * mu * y)/(2 * lambda) - (mu/(2 * lambda)) * 
	sqrt((4 * mu * lambda * y) + (mu * mu * y * y));
      u1 = drand48();
      if(u1 <= mu/(mu + x1)) {
	invgnum = x1;
      } else {
	invgnum = (mu * mu)/x1;
      }

      if(invgnum <= INVGAUSSMAX && invgnum > 0.5) {
	cnt[i] = invgnum;
	i++;
      }
    }

} /* End routine invgauss */

/****************************************************************************/
/* This routine initializes the off time array anc session length array and */
/* gets the length of the object sequence.                                  */
/****************************************************************************/

void initialize()
{
  long i, junk;
  FILE *fp;

/* Get elements from name.txt */

  if((fp = fopen("name.txt", "r")) == NULL)
    {
      perror("Unable to open name.txt\n");
      exit(1);
    }

  while( fscanf(fp, "%ld\n", &junk) != EOF) num_seq++;

  fclose(fp);

  if (num_seq > MAXOUTPUT)
    {
      printf("Must increase MAXOUTPUT \n");
      exit(1);
    }

/* Initialize the off array to 0 */

  for(i=0;i<MAXOUTPUT;i++)
    {
      off[i] = 0.0;
      cnt[i] = 0.0;
    }

} /* End initialize */

/****************************************************************************/
/* The results routine opens off.txt and prints out the off times.  It also */
/* opens cnt.txt and writes the session lengths                             */
/****************************************************************************/

void results()
{
  long i, x;
  FILE *fp1;

  /* Open and write the output file off.txt  */

  if((fp1 = fopen("off.txt", "w")) == NULL)
    {
      perror("Unable to open off.txt\n");
      exit(1);
    }
  for(i=0;i<num_seq;i++)
    {
      x = off[i] * 1000;
      fprintf(fp1, "%ld\n", x);
    }

  /* Close up off.txt  */

  fclose(fp1);

  /* Open and write the output file cnt.txt  */

  if((fp1 = fopen("cnt.txt", "w")) == NULL)
    {
      perror("Unable to open cnt.txt\n");
      exit(1);
    }
  for(i=0;i<num_seq;i++)
    {
      fprintf(fp1, "%d\n", (int)rint(cnt[i]));
    }

  /* Close up cnt.txt  */

  fclose(fp1);

} /* End results */




